**深入理解Java虚拟机** 1-39 Jun 5
1. Java是一个广受欢迎的编程语言，主要原因有：
   1. 结构严谨面向对象；
   2. 实现了一次编译到处运行；
   3. 安全的内存管理和访问机制，避免的绝大部分的内存泄漏和指针越界问题；
   4. 热点代码检测和运行时编译优化；
   5. 完善的API和第三方库。
2. Java技术体系：java程序设计语言，各硬件平台的JVM的实现，Class文件格式，Java类库API，第三方类库。
3. JVM家族：
   1. 最早JDK 1.0用的是Sun Classic，纯解释器执行，若要使用即时编译器就得用外挂。
   2. JDK 1.2时Exact VM发布，特点是使用准确式内存管理，能准确分辨内存中放的是否为指针。
   3. 使用范围最广的是HotSpot VM，有热点探测和即时编译的能力，编译器和解释器协调工作，速度大幅提升。
   4. IBM J9和BEA JRockit，与HotSpot并称三大商业VM。J9以模块化见长，JRockit是编译型VM，速度更快。
   5. 还有嵌入式系统的Mobile/Embedded VM，硬件专用的BEA Liquid/Azul VM，商业竞争致死的Microsoft VM等。
4. 展望Java技术的未来，Graal VM可以作为几乎任何语言（Java、C/C++、Python…… ）的运行平台，基本工作原理  
   是将这些语言源代码或中间格式（如LLVM字节码）经解释器转换为能被Graal VM接受的中间表示（称程序特化）。
5. Java的天生劣势——启动时间长、预热满、内存消耗大，特别是微服务中这些问题更加明显，催生了新的技术：
   1. 程序类型信息共享（AppCDS），可以跨进程缓存类信息，提升下次启动速度。
   2. 更彻底的解决方案是提前编译（AOT），解决第一次慢的问题，但是破坏了"一次编译到处运行"的特性。
   3. Substrate VM满足了AOT的需要，它是Graal VM里新出现的小运行时环境，目标是代替HotSpot，支持AOT后的  
    程序执行。其原理是采用指针分析技术，从程序入口出发，搜索所有可达代码，执行初始化并放到快照。  
    但这也决定了程序必须封闭，不能动态加载其他不可知的代码、类库。

**深入理解Java虚拟机** 42-61 Jun 6
1. Java运行时数据区包括：
   1. PC，是控制流指示器，故是线程都私有的。
   2. Java虚拟机栈，方法执行时用到的内存，每个方法有个栈帧，栈帧里分局部变量表、操作数栈、动态连接、  
   方法出口等。也是线程私有的。
   3. 本地方法栈，跟2类似，区别是本地方法栈是C++函数用的栈，也是线程私有。
   4. Java堆，所有线程共享的存放对象实例的地方，是GC管理的内存区域。其中也可以有线程私有的空间TLAB。
   5. 方法区，放类信息、常量和静态变量，为所有线程所共享。 
   6. 运行时常量池，是方法区的一部分，放各种字面量与符号引用，具备动态性，即运行时也可以放新的数据。
2. JVM会用到直接内存，它已不属于Java运行时，它基于通道和缓冲区进行I/O，避免了JVM来回复制数据。
3. 创建对象时要分配内存，为了使线程安全，分配内存可以使用两种方式：
   1. 同步，实际上HotSpot就是使用CAS（compare and swap）加上失败重试保证安全的。
   2. 本地线程分配缓冲（TLAB），在线程本地缓冲区分配，用完了才需要同步锁定。
4. 内存中的对象分为三部分：对象头、实例数据、对齐填充。其中头包含Mark Word，即自身运行时数据（hash、  
  GC分代年龄、锁状态、偏向线程ID等，占32或64位）；还包含类型指针，这是Java反射机制的基础。
5. 访问Java对象一般有两种方式：
   1. 句柄访问：reference->句柄->实例，优点是对象被移动时只改变句柄指向即可，无需改reference。
   2. 直接访问：reference->实例，优点是少一次内存引用，访问更快。

**深入理解Java虚拟机** 61-75 Jun 7
*内存溢出异常，垃圾回收*
1. 当JVM内存不足以分配要新建的对象时，就会出现内存溢出异常，包括OutOfMemoryError和StackOverflowError。
  前者是因为栈帧动态扩展时无法申请到足够内存，可以发生在堆、方法区和直接内存。后者是因为线程请求栈深度  
  大于最大允许的栈深度，会发生在虚拟机栈和本地方法栈。
2. 最早的垃圾收集出现在Lisp语言中，诞生于60年代，lisp作者McCarthy早就提出GC要考虑的几个问题：
   1. 哪些内存需要回收？
   2. 什么时候回收？
   3. 如何回收？
 
   如今Java的GC经历了数代演变，越来越成熟、自动化和高效。
3. 哪些内存需要回收呢？对于Java来说，PC、栈跟随线程而创建/销毁，所以需要考虑的就剩堆和方法区了。
4. 怎么判断内存可以回收或说对象已死呢？
   1. 引用计数法：给对象加一个计数器，记录被引用次数，0表示是垃圾。简单但有循环引用问题没被Java采纳。
   2. 可达性分析算法：从"根"递归遍历引用对象，遍历不到的就是垃圾。其中根可以是虚拟机栈、静态变量、常量  
   池里的引用、本地方法栈引用的对象、虚拟机内部引用（如Class对象）、被同步锁持有的对象等。除此之外，  
   根据用的垃圾收集器及当前回收的内存区域不同，还可以有其他对象临时作为根，比如分代收集和局部回收。
5. 实际上，引用与否决定回收过于粗放了。Java将引用扩充为强、软、弱、虚四种引用，强引用不可回收，其他三个  
  可回收性逐个增强：软引用可以在内存要溢出时回收，弱引用可以在每次垃圾收集时回收，虚引用不影响回收，  
  作用只是为对象被回收时提供一个系统通知。
6. 方法区的GC相对性价比更低，因为要做一些苛刻的判断，排查出（一般很少量的）常量和类型，进行内存回收。  
   方法区的垃圾判定要同时满足三个条件：所有对应实例已回收、加载器已回收、不被反射使用。在大量使用反射、  
  动态代理或者GCLib等字节码框架的场景中，方法区的回收还是必要的，以在必要时降低内存压力。

**深入理解Java虚拟机** 75-89 Jun 9<br>
*垃圾收集算法，HotSpot实现细节*
1. **分代收集理论**：多数程序在运行过程中产生的多数对象都是会迅速成为垃圾的，少数对象则一直被引用。所以，  
  可以将堆内存划分成不同的区，放不同的年龄的对象。这样一来还可以在不同的区使用不同的算法，因地制宜。  
  一般至少分新生代和老年代两个区，分代引入跨代引用问题——老年代引用新生代，回收后者还需要遍历前者。
2. **标记清除算法**：最基础的GC算法，分为两个阶段——标记存活对象和清除其他对象。这个算法存在两各大问题，  
  第一、不稳定，对象越多则GC所需时间也越长；第二、内存碎片化，甚至会导致大对象无处落脚，频繁GC。
3. **标记复制算法**：将内存两等分，一块放新对象，GC时将活的对象拷贝到另一块，两块角色互换重复前面过程。  
  其优点包括：简单地顺序分配、避免了碎片化的内存，缺点是需要的内存双倍于最大能分配的。针对内存浪费，  
  有一种优化，将两块内存区大小比例改成N:1，浪费1/(1+N)，N越大则浪费越少。但是得确保存活对象<1/(N+1)。
4. **标记整理算法**：标记复制算法在处理老年代多的情况时会严重浪费，因为这个场景的N会小。于是，有了这个  
  整理的算法——标记之后，将存活的对象都移动到内存的一端，清理掉其余空间。空闲和被占据内存界限分明，  
  不浪费内存，且提高了内存分配的性能（否则需要维护、访问复杂的数据结构如空闲链表）。代价是需要大量  
  的时间来移动对象，对象越多则耗时越长。
5. 简单记录一下HotSpot的GC相关算法的实现：
   1. 根节点枚举：要标记存活对象就得遍历所有引用，但直接遍历所有对象未免太低效，HotSpot用OopMap记录  
   对象的偏移量对应的数据类型，避免了扫描时一个对象不漏地从方法区查找。
   2. 安全点：OopMap会随着程序的执行一直动态变化，HotSpot实际只在特定了指令处记录这些信息，记录处  
   即所谓的安全点。所有线程需要在GC前跑到安全点，可采用主动式中断——线程运行到安全点就挂起自己。  
   HotSpot使用内存保护陷阱（在需要时将某内存页面设为不可读）的方式，在异常处理器中挂起用户线程。
   3. 安全区域：如果用户线程无法到达安全点，比如sleep了，那我们得扩大安全点的概念到区域。
   4. 记忆集、卡表：为避免扫描所有老年代，可以将要扫描的加入记忆集。卡表是记忆集的一种实现，用数组  
   （每个元素即一个卡页，可含多个对象）记录了对象->堆内存的映射，用dirty标志页是否含跨代引用。
   5. 写屏障：如何维护卡表，如增加元素和改变dirty标志？执行字节码时JVM好做这件事，但如果是即时编译呢？
   那得有机器码层面的手段，在每个赋值操作中加入卡表的维护，HotSpot使用写屏障实现，其本质是AOP。
   6. 并发的可达性分析：前面说标记采用可达性分析算法，为了降低可达性分析的耗时，可以采用多线程进行。
   首先我们先了解三色标记，使用白、黑和灰分别表示一个对象尚未被GC访问或不可达、引用都被访问且存活、  
   部分引用被访问。考虑用户线程和GC线程同时工作，用户线程在修改对象，一个严重后果是把存活对象标记  
   为死亡了。对应的三色图变化是：只存在GC线程的情况下，对象间是黑连着灰，灰连接白；若存在用户线程，  
   它可能切断灰色G->白色W的引用，并且建立黑色B->W的引用（B不在被扫描），导致W被误标记为死亡。
   这个问题有俩解决方案：增量更新、原始快照。其中，增量更新是说在B被增加了到W的引用后，B要改成灰色；
   原始快照说的是G->W引用断开后，要将W改成灰色，换句话说，我们总会扫描G->W中的W。


**深入理解Java虚拟机** 89-104 Jun 11<br>
*经典垃圾收集器*
1. Serial和Serial Old：历史最悠久的收集器，运行过程中会先停掉所有用户线程，对新生代采取复制算法回收内存，  
  对老年代采取标记-整理算法回收内存。用户线程都停掉，称Stop The World（STW），所以停顿时间可能很长，  
  优点是无线程交互开销，很高效，适用于资源受限的环境。
2. ParNew：相当于Serial的多线程并行版本，不同点是新生代回收时并行（并行度跟CPU核数有关）运行多个线程。
3. Parallel scavenge：基于标记复制算法的新生代收集器，跟ParNew有不少相似之处，特点是关注吞吐量，即用户  
  线程时间/总时间。用户可以通过-XX:MaxGCPauseMillis控制最大停顿时间，值越大则吞吐量会呈现上升趋势。也  
  可以通过-XGCTimeRatio直接控制吞吐量，背后机制是调整新生代、老年代的大小。-XXUseAdaptiveSizePolicy  
  可以让收集器自适应调节，用户只需要指定-Xmx，其他如Eden跟Survivor的比例、晋升老年代对象大小等细节参数  
  都是自动调节的。
4. Parallel Old：基于标记整理算法，是Parallel Scavenge的老年代版本，二者可以搭配使用。
5. CMS（Concurrent Mark and Sweep）：关注响应速度的老年代收集器，主要特点是并发标记，整体过程如下：
   1. 初始标记：标记一下GCRoot能直接关联到的对象，仍然STW，不过耗时很短。
   2. 并发标记：可以跟用户线程并发进行，耗时最长的阶段。
   3. 重新标记：标记并发过程中用户线程产生的"浮动垃圾"，需要STW，时间比并发标记短。
   4. 并发清理：清理垃圾，可以跟用户线程并发。
   
   是低停顿垃圾收集的第一次成功尝试，但是缺点也不少：资源少的情况下，因为线程竞争可能大幅降低吞吐量。
   浮动垃圾的产生，需要GC提前进行，无法处理浮动垃圾时可能出现长耗时的Full GC。标记清除算法有碎片问题。
6. Garbage First：GC技术的里程碑式成果，它适用于新生代和老年代，可以由用户指定停顿时间。G1开创了Region  
  堆布局，即连续的Java堆划分成大小相等的多个Region，每个都可根据需要扮演新生代的Eden、Survivor和老年代  
  空间。它回收的思路是哪个Region回收收益最大就先回收哪个，收益即空间大小和(1/耗时)的经验值，用优先级  
  列表进行选择，这就是Garbage First的名字的由来。其过程如下：
   1. 初始标记。
   2. 并发标记，可跟用户线程并发执行。
   3. 最终标记，因为采用原始快照方式解决并发标记问题，所以并发标记完需要再标记一下遗留的对象。
   4. 筛选回收，要暂停用户线程，根据收益回收。
   
   G1的优势很明显，最关心的是哪块内存回收快又多，而不追求一次清理干净。只要收集速度跟得上对象分配速度，  
   那一切就会很完美，避免了Full GC。另外用户可以指定期望的停顿时间，G1会尽量平衡停顿和吞吐量。G1比CMS  
   擅长处理堆内存较大的场景。缺点是需要的额外内存空间大，可能达到堆的20%甚至以上。


**深入理解Java虚拟机** 104-120 Jun 12<br>
*低延迟垃圾收集器*
1. 垃圾收集器最重要的三个指标是内存占用、吞吐量和延迟。随着硬件的发展，我们对内存占用代价的容忍度提高，  
  而且吞吐量也会更高，所以GC优化的目标大多落到了低延迟。Shenandoah和ZGC实现了低延迟的目标——停顿  
  时间在10ms只内，而且跟内存大小无关！
2. **Shenadoah**：是Redhat开发的，因说不清的利益关系而不被Oracle认可，于2014年被贡献给OpenJDK。它跟G1  
  有很多相似之处，有相似的内存布局，在初始标记和并发标记阶段处理思路也一致。不同点有：
   1. 支持并发整理和并行的回收线程。
   2. 默认不使用分代收集。
   3. 摒弃了G1中耗费大量内存的记忆集，取连接矩阵而代之。

   工作过程分9阶段：初始标记->**并发标记**->最终标记->并发清理->**并发回收**->初始引用更新（更新对旧对象的引用）  
   ->**并发引用更新**->最终引用更新->并发清理
3. **ZGC**：出现于JDK11，是Oracle开发的，目前性能最好的垃圾收集器。也基于不分代的Region，使用了读屏障、染  
  色指针和内存多重映射等技术实现的可并发的标记-整理算法，以低延时为首要目标。
   1. 用转发指针和读屏障来实现并发整理，此读屏障不同于上述Shenadoah的，而是更加复杂精巧。
   2. ZGC标志性设计是染色指针技术，即64位的指针本身留几位携带tag信息，而非在对象上，减少了内存访问。
   3. 工作分为4个阶段：并发标记（在指针上进行）->并发预备重分配(统计得出要收集的Region，组织成重分配集)  
     ->**并发重分配**（复制存活对象，其中用户线程引用的对象在被访问时会被内存屏障截获，转发到新的地址上，  
    称指针的*自愈*）->并发重映射（修正指向旧对象的引用，因为可自愈故该步不紧迫，可以放到下次GC完成）。


**深入理解Java虚拟机** 121-137 Jun 13<br>
*垃圾收集器的选择，内存分配回收策略*
1. 面对这么多垃圾收集器，我们选择时需要权衡多种因素，包括关注点、硬件、操作系统、JDK版本等。
   1. 如果有充足预算但调优经验不足，可以选择Azul的Vega或Zing VM，这样就能使用C4了。
   2. 如果能掌控软硬件型号，使用较新的版本，关注延迟，那可以尝试ZGC。
   3. 如果运行在Windows系统，那就无缘ZGC了，可以尝试Shenandoah。
   4. 如果软硬件和JDK版本落后，可以根据堆大小选择CMS或者G1。
2. 关于Serial垃圾回收，下面例子展示了对象如何在Eden、Survivor和tenured分配：
  
   ```
   代码：
   private static final int _1M = 1024*1024;
    public static void main(String[] args) {
        byte[] alloc1, alloc2, alloc3, alloc4;
        alloc1 = new byte[2*_1M];
        alloc2 = new byte[2*_1M];
        alloc3 = new byte[2*_1M];
        alloc4 = new byte[4*_1M];
    }

   运行和打印GC情况，配置的堆大小为20M，年轻代10M，其中Eden占8M，够分给前三个变量，第四个无法在Eden分配：
   (base) ➜ java -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:+UseSerialGC -XX:SurvivorRatio=8 TestAlloc
   [GC (Allocation Failure) [DefNew: 6651K->268K(9216K), 0.0010510 secs] 6651K->6412K(23552K), 0.0010680 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
   Heap
    def new generation   total 9216K, used 4529K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)
     eden space 8192K,  52% used [0x00000007be800000, 0x00000007bec290e0, 0x00000007bf000000)
     from space 1024K,  26% used [0x00000007bf100000, 0x00000007bf143338, 0x00000007bf200000)
     to   space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)
    tenured generation   total 14336K, used 6144K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)
      the space 14336K,  42% used [0x00000007bf200000, 0x00000007bf800030, 0x00000007bf800200, 0x00000007c0000000)
    
   ```
3. 对象进入老年代有几种情况：
   1. 对象较大，HotSpot提供参数-XX:PretenureSizeThreshold参数设置多大可以直接放老年代，避免来回复制的开销。
   2. 存活久，可以通过-XX:MaxTenuringThreshold设置对象经过几次复制会放到老年代。
   3. 空间分配担保，Minor GC之前要检查老年代最大可用连续空间是否>新生代对象占用的空间，否则根据参数  
   -XXHandlePromotionFailure判断触发Full GC还是冒险进行Minor GC。
   4. 另外，年龄作为晋升老年代的依据，其判断标准并不完全固定，当Survivor中相同年龄的所有对象大小之和>  
   Survivor空间的一半的话，也会直接提前进入老年代。

**深入理解Java虚拟机** 138-151 Jun 14<br>
*JVM性能监控工具*
1. 在JDK的bin目录下，可以看到内置的工具，其中常用的有jps、jstat、jinfo、jmap和jhat、jstack等 ：
      ```
      (base) ➜  bin ls j*
      jar        javadoc    jconsole   jhat       jps        jstat
      jarsigner  javah      jdb        jinfo      jrunscript jstatd
      java       javap      jdeps      jjs        jsadebugd
      javac      jcmd       jfr        jmap       jstack
      ```
2. jps用于查看JVM进程，简单又常用。  
3. jtasat用于获取虚拟机统计信息。  
   <img src="/Users/shengjiesong/Pictures/screenshot 2022-06-14 at 23.53.20.jpg" width=50%>
4. jinfo获取Java配置信息，可以查看和调整虚拟机各项参数。  
   <img src="/Users/shengjiesong/Pictures/screenshot 2022-06-14 at 23.53.40.jpg" width=50%>
5. jmap常用来将内存影响导出为dump文件（快照）。  
   <img src="/Users/shengjiesong/Pictures/screenshot 2022-06-14 at 23.54.02.jpg" width="50%"/>
6. jhat可以配合jmap使用，将后者生成的dump文件转储快照进行分析。
7. jstack可以跟踪堆栈，常用来排查长耗时、死锁等线程调用相关问题。

**深入理解Java虚拟机** 151-175 Jun 16<br>
*JVM可视化故障处理工具*
1. JHSDB，基于服务性代理（SA）的进程外调试工具，功能涵盖了jmap、jstack、jinfo等工具的部分功能。
2. JConsole，基于JMX，可以通过JMX MBean收集信息和动态调整参数。可以分析内存、线程、类等数据。
3. Visual VM，功能最强大的监视和故障处理工具之一，除了常规监控还能做性能分析。
4. Java Mission Control，也基于JMX与虚拟机通信，可以持续地在线监控。


**深入理解Java虚拟机** 176-189 Jun 17<br>
*JVM调优案例分析（在应用部署层面的配置优化）*
1. 大内存案例：16GB物理内存、CentOS 5.4，单独运行一个文档管理服务，分配了12GB堆内存。  
   问题分析：经常服务停顿，Full GC耗时14秒/次。因为每次读文件到内存都相当于加载了一个大对象，没办法在Eden  
   分配而直接放老年代，导致Minor GC几乎不起作用，一到GC就是Full GC回收那么大内存，所以服务间歇性停顿。  
   解决：起多个进程，每个分配更小的堆（如2G）。另因磁盘会是瓶颈而CPU资源足，故GC采用CMS，降低延迟。
2. 堆外内存导致的溢出：基于B/S的电子考试系统，在32位、4GB的windows系统上运行，不定时抛出内存溢出异常。  
   问题分析：堆内存调大至1.6G（对于32位Win只能这么大），发现内存溢出更频繁，用jstat监视发现垃圾收集不频繁，  
   而且Eden、Survivor区、老年代和方法区的内存全都很稳定。这些都排除了，通过系统日志发现是Direct Memory异常。
   除了直接内存的内存溢出，还有线程堆栈、Socket缓存区、本地方法栈和本地内存等非堆内存也会存在类似问题。
3. 外部命令导致系统缓慢：运行在四路处理器的Solaris 10上的数字校园应用系统，基于GlassFish，发现处理器过载。  
   问题分析：通过dtrace发现fork系统调用占了CPU，再看Java代码，每个用户请求都会使用Runtime.getRuntime().exec()  
   调用Shell脚本——这很耗资源（即使外部命令本身很快），要JVM复制ENV起新进程执行命令。可用Java API代替。
4. 服务器虚拟进程崩溃：运行在两台双路CPU、8GB内存的基于B/S的MIS系统，频繁出现虚拟机进程自动关闭，日志显示  
   大量的"Connection reset"。发现该系统向另外一个系统发送请求，但后者性能太差，请求堆积且经常超时。后采用消息   
   队列实现系统交互，问题解决。
5. 不恰当的数据结构导致内存占用过大：说的是HashMap<Long, Long>中元素会达到100万个，MinorGC造成0.5s停顿，  
   因为它使用的是ParNew+CMS，很多对象经过Minor GC还是存活的，故需要大量的复制。要解决这个问题，考虑修改  
   配置，可以将Survivor区去掉，让对象迅速进入老年代。最好的办法是修改数据结构，因为HashMap<Long, Long>的  
   空间利用率太低了，作者分析了Mark Word、Klass指针、内存对齐等，发现空间利用效率只有18%。

**深入理解Java虚拟机** 189-209 Jun 18<br>
*JVM调优案例，客户端程序的调优*
1. 安全点导致长时间停顿：一个承担公共计算任务的离线HBase集群，使用G1收集器，其-XX:MaxGCPauseMills设置为  
  500ms但是实际的垃圾收集停顿经常达到3s以上。打印出GC日志分析，另外需要参数-XX:+PrintSafepointStatistics和  
  -XX:PrintSafepointStatisticsCount=1查看安全点日志发现有线程存在2s多的自旋。通过添加-XX:SafepointTimeout和   
  -XX:SafepointTimeoutDelay=2000参数找出慢线程，发现是RpcServer.listener线程。考虑到方法调用、循环、异常跳转  
  都会设置安全点，其中针对跳转，为了避免安全点多带来的负担，HotSpot做了一个简单优化--对int类型作索引的循环不  
  设置安全点，long或者更大范围的才设置。而实际上RpcServer线程里的循环本身就很耗时，于是将索引改成long类型，  
  果然解决了问题。这个性能很隐蔽，如果不熟悉垃圾收集和安全点，根本不可能想到这个原因。
2. 除了服务端性能要调优，客户端有时候也需要调，作者就拿他的Eclipse实操了一把，这里简单概括一下调优历程：
   1. 首先Eclipse运行在32位Windows 7、HotSpot 1.5 b64，Intel i5 CPU和4G内存。在初始配置-Xmx512m的情况下，  
   Eclipse启动耗时15秒。用VisualGC发现垃圾收集耗时4秒多，其中19次Full GC  
   耗时3s多，Minor GC触发378次，耗时近1s。加载类九千多，耗时四秒多。新生代40M、老年代472M。
   2. 升级JDK（5->6）。发现内存溢出问题！使用VisualVM发现PermGen空间一直扩展，也一直在耗尽。最终只达到  
    64M，没错这是默认的-XX:MaxPermSize，对于Eclipse应该不够用，但为啥JDK5没问题？经VisualVM看参数发现  
   JDK 5使用的是256M！实际上这是Eclipse的问题，Oracle收购Sun后，Eclipse没认出来JVM符合指定条件，于是没  
   设置该参数。解决办法就是为Eclipse手动设置该参数为256m。但启动时间比升级JDK前多一倍！？
   3. 分析发现JDK 6启动花了很多时间在类加载上，因为它比JDK 5多了很多类加载验证，通过参数-Xverify:none禁用  
    验证，然后确实跟JDK 5对应的启动速度接近了——12秒。
   4. 然后考虑GC时间，查看垃圾收集日志发现Full GC耗时太长，而且总伴随着老年代的扩容，干脆禁用扩容，直接将  
   其设置为96M，新生代提到128M。然后发现Minor GC有8次、Full GC有4次，总耗时接近2s。
   5. 但是Old Gen曲线显示并不存在空间用完的情况，是什么导致Full GC？运行jstat -gccause命令发现是System.gc()  
   导致了Full GC，那直接用参数-XX:+DisableExplicitGC禁掉即可。然后发现启动时间只需7s了！
   6. 最后，抛开Eclipse启动时间，改用它编译代码，发现每次GC要停顿近1s，而CPU使用率只有30%。啥也不说了，  
   改用并行度更高的CMS作为收集器（搭配ParNew），降低GC延迟。然后发现Full GC时间下降一个数量级。

**深入理解Java虚拟机** 211-224 Jun 19<br>
*class文件结构*
1. Java跨平台特性的基础是class文件。不止如此，class文件也是语言无关的，其他语言如Kotlin、Clojure、Groovy、  
   Scala只要能编译成字节码文件，也就可以在JVM运行。字节码的语言描述能力必定比Java语言本身更强大。
2. 老生常谈的class文件结构，最大的特点就是内容紧凑、无分隔符。不同类型内容，其前面有count暗示分隔位置：


 | 类型 | 名称 | 数量|
 |---|---|---|
 |u4 | magic | 1|
 |u2 | major_version | 1|
 |u2 | minor_version | 1|
 |u2 | constant_pool_count | 1|
 |cp_info | constant_pool | constant_pool_count-1|
 |u2 | access_flags | 1|
 |u2 | this_class | 1|
 |u2 | super_class | 1|
 |u2 | interface_count | 1|
 |u2 | interfaces | interface_count|
 |u2 | fields_count | 1|
 |field_info | fields | fields_count|
 |u2 | methods_count | 1|
 |method_info | methods | methods_count|
 |u2 | attributes_count | 1|
 |attributes_info | attributes | attributes_count|

3. 下面代码编译出来的字节码文件左下图所示（十六进制），最后一个红线后是常量池，13表示有18个常量：
  ``` java
    package clazz;
    public class TestClass{
	    private int m;
	    public int inc() {
	        return m + 1;
	    }
    }
  ```
<img src="/Users/shengjiesong/Pictures/screenshot 2022-06-19 at 22.40.10.jpg" width="56%"><img src="/Users/shengjiesong/Pictures/screenshot 2022-06-19 at 22.35.00.jpg" width="43%">

4. 上面右图是javap展示的常量池，这是最class中最复杂的结构，光类型就有17种（JDK 13后）。要分清各常量是啥，  
  需要注意每个18个cp_info中每个类型的不同。比如0x0000000a位置的0a表示的是方法符号引用，后面有1+2+2个  
  字节。紧接着第二行的0x03表示整型字面量，后面1+4字节是该整型数的信息……


**深入理解Java虚拟机** 224-251 Jun 20<br>
*class文件结构*
1. 接着常量池的绿框里是3*2字节的类访问标志、this类、父类。后面红框里是接口数及接口信息（0个）。  
  字段表结构如下表，对应的class内容如下图划红线部分。另外方法表同下面字段表，由此可以分析出  
  俩方法分别是构造器和inc()，在黄框里，俩方法用蓝色括出来了：

   <table>
    <tr><th>名称</th> <td>access_flag</td> <td>name_index</td> <td>descriptor_index</td> <td>attributes_count</td> <td>attributes</td></tr>
    <tr><th>类型</th><td>u2</td> <td>u2</td> <td>u2</td> <td>u2</td> <td>attribute_info</td></tr>
    <tr><th>数量</th><td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>attributes_count</td></tr>
   </table>    

   <img src="/Users/shengjiesong/Pictures/screenshot-class-structure.jpg" width="70%">

2. 方法的具体内容（蓝色括号里的）包含了Code属性，即方法栈、局部变量、代码、异常等信息，是最重要的  
  部分。以第一个方法即构造器为例，前4*2字节是访问修饰符、方法名、描述信息和属性数（1个，Code），  
  后面的`00 01 00  01 00 00 00 05 2a b7 00 01 b1`就是Code属性内容，表示最大栈深为1、最多有一个  
  局部变量、代码长度是5、结尾的指令字节码（5个字节）。用javap分析的代码部分如下：  
   <img src="/Users/shengjiesong/Pictures/screenshot 2022-06-20 at 21.44.26.jpg" width="70%"/>   
   需要注意俩无参方法的args_size竟都是1，背后是Java的潜规则——this被访问时跟普通参数一样，都是首先  
   压栈再调用方法，所以实例方法的第一个参数固定是this。
3. 除Code属性，还有异常、代码行号表、本地变量表、源文件及其调试信息、类/实例变量、内部类等等复杂的  
  属性。要人工分析字节码文件，需要对照大量的结构表，在不熟练的情况下分析真的太耗时了……


**深入理解Java虚拟机** 251-261 Jun 21<br>
*字节码指令*
1. 跟汇编指令类似，JVM字节码也有操作码+操作数组成，它的一大特点是编译后不对齐，故需运行时从字节中  
  重建具体的数据结构。所以会牺牲些效率，但是节省了空间。JVM解释器一条条取出PC指定的指令执行。
2. JVM操作码设计上包含了类型信息，长度却限制在一个字节，故有些类型是没有对应指令的。
3. **指令分类**：
   1. 加载和存储，分别指将数据在栈帧中的局部变量表和操作数栈之间来回传送。加载局部变量用Tload[_N]，  
   数值存储到局部变量表用Tstore[_N]，加载常数用Tipush、ldc、iconst[_T]等。指令中的T表示都代表类型  
   N表示操作数，如0、1、2这些很小的操作数被合并到了指令中，也让代码更加紧凑。
   2. 加、减、乘、除、位操作指令无需多说，Trem求余，Tneg取反，TshT位移，TcmpT比较，iinc自增。
   3. 类型转换T2T指令，也无需多说，需要注意JVM窄化浮点数为整数时：浮点数NaN转为0；非无穷大数则按  
   IEEE 754的向零舍入模式——表示范围之外的数被转成最值。
   4. 对象的创建指令：new、newarray等，(get|put)(filed|static)用来访问实例或类变量。加载数组的一个元素  
    用T**a**load，相反存元素用Tastore。
   5. 管理操作数栈指令有pop、pop2出栈1、2个元素，dup[*]复制并压栈，swap用来互换栈最顶的俩元素。
   6. 控制转移指令ifX，X可以是eq、lt、null、nonnull、_acompne等等，复合条件分支指令是*switch，无条件  
   分支指令有goto、goto_w、jsr、jsr_w、ret。
   7. 方法调用指令有invokeT，T为interface时调用接口方法，在运行时搜索实现了该方法的对象并调用。
   8. 异常处理指令athrow，异常的处理使用异常表完成的，没有对应的字节码指令。
   9. 同步指令monitorenter和monitorexit对应于synchronized关键字。
4. 在满足JVM规范的前提下，具体实现的JVM可以有灵活的Class处理方式，如将字节码翻译成另一种VM指令，  
  再比如即时编译技术，这俩都是在加载或执行时的私有实现。
5. 总结一下class文件：平台无关，语言无关。格式紧凑、稳定、可扩展。



**深入理解Java虚拟机** 263-279 Jun 23<br>
*类的加载时机及过程*
1. Java语言中，类型的加载、连接和初始化过程都是在程序运行时进行，这是Java极具灵活性和动态扩展性。
2. 类的生命周期：加载、连接（验证、准备、解析）、初始化、使用、卸载。类在以下情况须被加载到JVM：
   1. 执行到字节码指令new、getstatic、putstatic或invokestatic时。
   2. 对类型进行反射调用时。
   3. 初始化一个类发现其父类尚未被加载时。
   4. 虚拟机启动时，得指定main方法所在主类，这个主类会被初始化。
   5. 使用动态语言支持时（java.lang.invoke.MethidHandle被解析出的方法句柄对应的类要初始化）。
   6. JDK 8新特性中，含default方法的接口的实现类被初始化前，此接口需先被初始化。
3. 除了上面加载的情况，需要注意"被动引用"情况下不会初始化引用类：
   ```
   // 1. 通过子类引用父类的类变量，不会触发子类的初始化
   Object a = Child.parentStaticObj;
   // 2. 创建某个类的数组，不会触发该类的初始化
   Foo[] foos = new Foo[];
   // 3. 常量（static final）的引用不触发其所在类的初始化，因为常量被放到了常量池
   String constString = ConstClass.FOO;
   ```  

4. 类加载过程的具体动作：
   1. 加载：
      1. 通过类的权限定名来获取对应的二进制流，这个流可以来源于文件、网络、内存等。
      2. 将流代表的静态存储结构转化为方法区的运行时数据结构。
      3. 在内存中生成代表该类的java.lang.Class对象。
   2. 验证，避免二进制流的危险，因二进制流可来源于Java语言编译之外的过程，可能绕过Java的安全性。
      1. 格式验证，需要流以魔数0xCAFEBABE开头，主次版本、常量类型、常量索引、编码等要合法。
      2. 元数据验证：是否有父类，是否非法继承一个类，是不是抽象类，是否实现了该实现的所有方法。
      3. 字节码验证：保证操作数栈跟指令代码序列配合，保证跳转方法调到本方法内，保证类型转换有效。
      4. 符号引用验证：保证引存在且在指定类中，保证可见性无误。
   3. 准备，给类变量分配内存及赋初值。注意这个赋初值是默认值，而非代码指定的。比如
   `public static int value = 123;` 被赋的值是**0**，后面初始化阶段putstatic被调用后，值才是123。
   4. 解析：符号引用替换成直接引用。
      1. 类或接口的解析：将一个类对另一个类的引用生成对象，期间会检查权限（JDK 9还有模块限制）。
      2. 字段解析：按照指定类、类实现的接口、类的父类的顺序进行引用的匹配。
      3. 方法解析：跟字段解析很想，但是多了对目标类的校验——是否为接口、是否为抽象类。
      4. 接口方法解析：类似于上，但接口存在多重继承，规范没限制必须使用哪个，实现者决定。
      
   5. 初始化，即`<clinit>()`的执行过程：
      1. `<clinit>()`是对静态变量和静态语句块的有序封装（按出现顺序）。
      2. 一个类被初始化前，会先执行完父类的`<clinit>()`。
      3. 如果一个类没有静态语句块和静态变量的赋值，那编译器可以不为它生成`<clinit>()`。
      4. 接口有静态赋值操作的话，也会存在接口的`<cinit>()`，但是不会先执行父接口的`<clinit>()`，  
      因为只有当父接口中定义的变量被使用时，父接口才被初始化。
      5. JVM需要保证一个类的`<clinit>()`方法在多线程环境中被正确加锁执行。


**深入理解Java虚拟机** 279-292 Jun 24<br>
*类加载器*
1. 就是加载类的代码，这是Java的一项创新，在类层次划分、OSGi、程序热部署、代码加密中发挥核心作用。
2. 类加载器的类型：
   1. Bootstrap，用来加载rt.jar等基本类库，用C++语言实现的。
   2. Extension，加载扩展目录下的类库。
   3. Application，程序默认类加载器，可以通过ClassLoader.getSystemClassLoader()获得。
   4. 用户自定义。
3. 双亲委派模型：上面加载器相邻俩中上一个是下一个的"父加载器"，加载一个类时会首先查找类是否已加载，  
   否则委派当前加载器的父加载器加载。这一机制保证了类的优先级和安全性（不会被随意替代）。
4. 破坏双亲委派模型：
   1. 在JDK1.2之前还没有该机制，后为了兼容那些代码，而无法避免loadClass()被覆盖，而添加findClass()，  
    用户可以覆盖它，实现对父加载器无法加载的类做自定义加载。
   2. JNDI，目的是集中地管理资源，需调用SPI的实现，Java为此引入线程上下文加载器，支持自定义加载。
   3. 代码热替换，比如OSGi代码热部署。
5. 模块化系统：在JDK9引入，让模块的依赖不再以jar为单位，可以做到更精细化和轻量级（可以不用模块化，  
   因为是向后兼容的）。模块化还完善了方法、字段访问上的安全机制。  
   模块化下的类加载器的变动：第一、Platform Class Loader取代了Extension。第二、类加载器不再派生自  
   java.net.URLClassLoader，而是java.internal.loader.BuiltinClassLoader，其中实现了模块化加载逻辑。


**深入理解Java虚拟机** 293-315 Jun 25<br>
*虚拟机字节码执行*
1. jVM对字节码的解释执行依赖于栈，每个方法的调用都产生新的栈帧，栈帧内容包括：
   1. 局部变量表：方法参数和方法内部定义的局部变量，编译时就写入Code属性中的固定的东西。
   2. 操作数栈：指令执行时会用到它存取内容，方法调用则用它传参。
   3. 动态连接：栈帧包含指向运行时常量池中**该栈帧所属方法的引用**，以支持方法调用过程中的动态链接。
   4. 方法返回地址：方法执行结束返回到调用者方法中，返回到的具体位置就是该地址。
   5. 附加信息：其他。动态连接、方法返回地址和这个共称为栈帧信息。
2. Java的多态性使方法被调用时需要确认调用哪一个方法，涉及重写和重载。
   1. 解析：编译器即可确定调用的方法调用，包括这些invoke指令invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic。
   2. 分派，调用方法时，如果运行时才能动态确定调哪个方法，那么该调用就是分派，本省就具备动态性。
      1. 静态分派：例如方法`feedPet(Pet pet)`，Pet自身及多个子类作为该方法的参数都有其重载实现，  
      现以pet为参数调该方法`Pet pet = flag ? new PetImpl1() : new PetImpl2()`会依静态类型  
      Pet来确定调用Pet作为参数的那个feedPet方法。要注意，这个跟解析不互斥，是不同层面的解释。
      2. 动态分派：在重写方法中常有体现，例如`pet.eat()`的方法调用的确定，需要依赖对pet实际类型的  
      分析来确认调用哪个方法。为了避免频繁的解析调用哪个方法，可以在方法区保存虚拟方法表。


**深入理解Java虚拟机** 315-334 Jun 26<br>
*虚拟机字节码执行*
1. JVM字节码指令在二十年间只增加过一条，就是invokedynamic，为动态语言、和lambda表达式打下基础。
   1. 动态语言跟静态语言的本质区别是，变量本身没有类型，其值才有类型，值的类型只能在运行时确定。  
      ```
      // Java中要实现下面sayHello的方法调用，可在运行时动态生成字节码，实现具体的item类型适配，但开销大
      var arrays = {"a", new ObjectX(), 20, ...};
      for (item in arrays) {
          item.sayHello();
      }  
      ```  
   2. JDK 7新增java.lang.invoke包，利用新机制——**方法句柄**来动态确定目标方法，类似于C语言函数指针。
      `void sort(List list, Comparator c)`
2. Java字节码的解释执行的基础是栈，比如要计算"1+1"，两个操作数会先压入栈，调用iadd指令后，将结果  
  存到局部变量表。具体字节码实例如下：
   ```
   iconst_1
   iconst_1
   iadd
   istore_0
   ```
   相对于基于寄存器的计算`add eax, 1`，基于栈的运算频繁访问内存，会更慢，但优点是可移植。
3. 用一个简单的算术运算说一下栈的操作过程，首先java代码：
   ```
      public int calc() {
        int a = 10;
        int b = 20;
        int c = 30;
        return (a+b) * c;
    }
   ```
   编译之后用javap可以看到字节码：
   ```
    Code:
   stack=2, locals=4, args_size=1
      0: bipush        10
      2: istore_1
      3: bipush        20
      5: istore_2
      6: bipush        30
      8: istore_3
      9: iload_1
     10: iload_2
     11: iadd
     12: iload_3
     13: imul
     14: ireturn
   LineNumberTable:
     line 3: 0
     line 4: 3
     line 5: 6
     line 6: 9
   ```
   地址偏移量为0~8的指令bipush和istore指令将整数压栈后为局部变量表赋值。  
   9~10用来将10和20放到栈上。  
   11是调用加法，俩操作数被弹出栈，得到的结果30会放到栈顶。  
   12~13将30放到栈上后执行乘法，同样俩操作数会被弹出，乘积在栈顶。   
   14则返回该乘积。


**深入理解Java虚拟机** 335-348 Jun 28<br>
*类加载器案例*
1. Web服务器，一般要具备以下功能：
   1. 不同Web应用程序的Java类库的隔离。
   2. 同一服务器上的两个Web应用程序所用类库可以共享，防止内存过度膨胀。
   3. 保证安全性不受外来Web应用的影响。
   4. Web应用热替换JSP等。
2. 所以，单独的class path不能满足需求了，需要有多个路径放类库，以Tomcat为例：
   1. common目录中，可被Tomcat和所有Web应用程序共同使用。
   2. server目录中，可被Tomcat使用，而对Web程序不可见。
   3. shared中，可被所有的Web程序使用，但Tomcat自己不可见。
   4. WebApp/WEB-INF中，只为该Web应用程序可见。  
   Tomcat自定义Catalina和Shared类加载器都以Common为父加载器，Jsp的父加载器是WebApp加载器，  
   后者的父加载器是Shared类加载器。根据加载器名字，它们分别加载哪些类库就很明显了。
3. OSGi是Open Service Gateway Initiative的缩写，Java动态模块化规范。其中的模块称bundle，通过平级依赖  
  的声明来组织package和class，只有export过的才能被外界访问。
4. 字节码生成技术和动态代理：首先我们最早接触的javac就是干这个的。字节码生成常用于JSP编译、编译时  
  织入的AOP框架、动态代理技术。其次，说到动态代理，我们使用Proxy或者InvocationHandler或者简单的用   
  Spring框架，就用了这个技术，按照class规范拼装字节码。
5. Backport工具——Java的时光机，如果你的项目（产品）是一个又老又大的一坨，而你想用新JDK继续开发，  
   那么可以用这种工具，将基于新JDK写的的代码转为老版本的。工具包括Retrotranslator和Retrolambda等。


**深入理解Java虚拟机** 348-357 Jun 28<br>
*实战-远程执行Java代码*
1. 需求："在远程服务器执行临时代码"，以方便简单的问题定位。应该具备的特性有：不依赖特定的JDK版本，  
   不改变原有服务端程序的部署，不依赖第三方库，不依赖原有程序，考虑到交互性选择Java开发，执行的结果  
2. 需要输出到客户端，并且包含stdout和stderr。
3. 思路：
   1. 在哪编译Java代码，让它远程服务端运行？考虑不依赖特定JDK版本，选择在客户端编译。
   2. 如何执行编译后的Java代码？自定义类加载器，让它加载、反射来调用其main函数。
   3. 如何收集Java代码执行的结果？可以编辑待执行类的字节码，将System.out的引用替换为自定义的。
4. 实现：不详述了，主要就是让自定义的ClassLoader在加载类时做一下字节码的修改，以将常量池对System的  
  引用改为自定义的HackSystem。HackSystem中只改out和err引用PrintStream对象，其他直接转发给System  
5. 最后，写一个JSP文件调用这个程序执行临时代码，后者要先编译好传到服务器（作者用Eclipse插件的方式  
  代替了浏览器），在JSP文件里修改待执行的class文件的路径运行即可。


**深入理解Java虚拟机** 358-387 Jun 30<br>
*前端编译优化*
1. javac就是前端编译的例子，将Java源代码变为字节码。除此还有后端编译——源码或字节码转变为机器码。
2. javac是用Java编写的，其编译功能包括以下过程：
   1. 准备过程：初始化插入式注解处理器。
   2. 解析与填充符号表，包括词法、语法分析以构造ABT，以及产生符号地址和符号信息。
   3. 插入式注解处理器的注解处理，影响javac的编译行为。
   4. 分析与字节码生成：标注检查，数据流和控制流分析，解语法糖，生成字节码。
3. 上面提到的注解处理器在编译时生效，扩展了注解的功能（运行时）范围，Lombok就利用了这一点。
4. 字节码的生成会生成`<init>()`和`<cinit>()`方法，类中有代码块和静态代码块的话，就会把它们放进去。  
  另外，还会做一些优化，比如将String的加操作变为StringBuilder的append操作，等。
5. 解语法糖就是将带语法糖的代码变为普通代码了，比如泛型、自动装箱、for-each循环等。
6. Java中的泛型是以擦除的方式实现的，就是说在编译后的字节码中抹去泛型信息的存在，其对应的是具现化。
   擦除主要为了向后兼容，但是引入了性能问题——不必要的拆装箱——如原始类型放到集合中，因为int、long  
  与Object间无法强制转换，那就不支持原生类型泛型了，对于Integer、Long为泛型的，得在擦除后自动装箱。  
  另外一个问题是无法优雅实现重载，以带泛型的类对象作为参数的话，不同泛型并不使方法的签名不同。
   ```
   // 下面代码无法编译通过，因为俩method会有完全相同的签名。
   void method(List<String> s){}
   void method(List<Integer> i){}
   
   // 一个不优雅的改进是用返回值类型区分方法
   String method(List<String> s){}
   int method(List<Integer> i){}
   ```

**深入理解Java虚拟机** 388-436 Jul 2<br>
*后端编译优化*
1. **即时编译**（JIT）：在运行时探测热点代码，将其编译为机器代码并优化，代替字节码的解释执行。
   1. 优势是可以根据执行热点来编译字节码为本地机器码，提高运行效率。劣势是比AOT执行慢，耗内存。
   2. HotSpot内置了两个（JDK 10增加了第三个，Graal）：客户端编译器，服务端编译器，分别简称为  
   C1、C2，前者侧重于速度，后者侧重优化。可用参数"-server"和"-client"决定JVM使用哪个编译器运行。
   3. 不管在用哪个编译器，默认解释器跟编译器都是混合使用的：
      <img src="/Users/shengjiesong/Pictures/screenshot 2022-07-02 at 22.28.13.jpg" width="80%"/>  
     我们可以通过参数"-Xint"或"-Xcomp"指定只使用解释器或编译器：
      <img src="/Users/shengjiesong/Pictures/screenshot 2022-07-02 at 22.30.52.jpg" width="80%"/>
   4. 编译器可能在优化时采用了激进的办法，比如虚拟方法内联后，可能还会有新类加载，导致原来继承结构  
    发生变化。此时可以通过逆优化（即时编译的逆过程）回到解释执行，这种方案也称"逃生门"。
   5. 分层编译，在JDK 7服务端模式中默认开启，会根据编译、优化的规模与耗时，划分出不同编译层次：
      1. 第0层，无编译，纯解释运行；
      2. 第1层使用C1编译并做可靠优化；
      3. 第2层会在第1层的基础上，开启方法和回边次数统计等有限的性能监控功；
      4. 第3层，在第2层基础上开启全面性能监控，包括分支跳转、虚方法调用版本等统计信息；
      5. 采用C2进行更多耗时更长的优化，包括不可靠的激进优化。
   6. 编译过程有五花八门的优化，在两个阶段都会进行：
      1. 字节码->平台独立的高级中间代码表示（HRL），会进行方法内联、常量传播等基础优化。
      2. HIR->LIR，进行空值检查消除、范围检查消除等优化。
2. **提前编译**（AOT）：直接将Java代码编译成机器代码，对比JIT，完全消除了运行时编译的时间消耗。
   1. 这是AOT最大的优势。劣势是这种编译是平台相关的，不能做到"一次编译，到处运行"。不仅如此，运行  
   参数（如GC的选择）也会跟这种编译有耦合，编译优化需要配合所选参数。除此之外，AOT优化也不能  
   太过激进，它没有运行时性能分析的支持，也无法利用逃生门。
   2. AOT有两条不同的路径，一是跟C/C++一样直接静态翻译；二是把原本JIT在运行时进行的编译提前做好并  
   保存下来，下次运行到这些代码时加载一下运行即可，也称JIT缓存。
   3. JDK 9引入了jaotc这种AOT编译器，可以直接编译得到静态链接库，而非Class文件。
3. **编译优化**有很多类型，每种类型下还有不同技术。比如，属于循环变换的循环展开、循环剥离、安全点消除、  
  循环向量化等，属于语言相关优化的逃逸分析、锁消除、锁膨胀、自动装箱消除、消除反射、符号常量传播，  
  属于内存及代码位置变换的表达式提升、表达式下沉、冗余存储消除等，属于全局代码调整的内联、Switch  
  调整、基于热度的代码布局、全局代码外提等。
   1. 方法内联：将被调用方法的内容复制到调用处，取代调用，消除方法调用的开销。JVM发现一个接口方法  
    只有一种实现时，会默认这就是运行时的全貌，将该实现用于内联。后续若有问题，可以利用逃生门。
   2. 逃逸分析：分析对象的动态作用域，其调用可能只存在本方法中，或者逃逸到方法之外，或者被其他线程  
   引用。是比较前沿的、为其他优化提供依据的分析技术，比如：
      1. 如果确定对象不会逃出线程，那么可以进行栈上分配，对象可以随着栈的销毁而销毁。
      2. 如果确定一个对象不被外面方法访问，并且它可以拆解成JVM中原始数据类型，那就可以用标量替换  
      这个对象，避免了对象的创建。
      3. 如果确定一个变量不会逃逸出线程，那么它一定是读写安全的，其中同步操作可以被消除掉。
   3. 公共子表达式消除：比如`c * b + a + c * b`进行代数化简`a + E * 2`。
   4. 数组边界检查消除：不同于C语言的底层指针直接操作数组，Java为保证安全会检查数组边界，这带来了  
   性能问题。这种优化就是去掉每次访问元素时的边界检查，改用异常处理器的方式处理非法访问。

**深入理解Java虚拟机** 438-465 Jul 3<br>
*Java内存模型和线程*
1. 随着摩尔定律逐渐为Amdahl定律所取代，计算机性能的提高越来越多地依赖于并行化。多任务处理让处理器  
  的计算资源利用率更高，多处理器更是大幅提升了性能。另外，为应对内存跟处理器速度的悬殊，缓存被引进
  到计算机系统，使其更加复杂。这引入的一个重要问题是**缓存一致性**：每个处理器都有自己的高速缓存，里面  
  保存部分主存数据副本，多处理器操作同一块主内存时，怎么保证它们是一致的呢？答案是缓存一致性协议，  
  比如MSI、MESI、MOSI等。解决读写一致性问题。
2. 至于Java内存模型，也是类似的。不同线程有私有的工作内存，它们跟主内存间的数据操作也有些限制规则：
   1. 首先Java内存模型定义8种操作，JVM实现须保证它们都是原子的、不可再分的（long、double例外）：
      1. lock：作用于主内存的变量，使其变量表示变为一条线程独占状态。
      2. unlock：也作用于主内存的变量，解除其一条线程独占的状态。
      3. read：作用于主内存的变量，把一个变量的值从主内存传到线程工作内存，供后面load用。
      4. load：作用于工作内存的变量，把read到的变量值放到工作内存变量副本。
      5. use：作用于工作内存的变量，把变量值传递给执行引擎，JVM遇到用该值的指令时会执行该操作。
      6. assign：作用于工作内存的变量，将执行引擎提供的值赋给工作内存的变量。
      7. store：作用于工作内存的变量，将变量值传送到主内存。
      8. write：作用于主内存的变量，把store得到的变量放入主内存的变量。
   2. 下面是基本操作的规则：
      1. 不允许read和load、store和write操作之一单独出现，保证主内存和工作内存互相读写操作的完整性。
      2. 不允许一个线程丢弃最近的assign操作，保证线程改变的值同步到主内存。
      3. 不允许一个线程无故（没发生assign）把数据从工作内存同步回主内存。
      4. 一个新的变量只能在主内存产生。
      5. 一个变量在同一时刻只允许一条线程对其lock（可多次），执行同样次数的unlock才能解锁。
      6. lock会清空工作内存此变量的值，下次要使用必须重新load或assign来初始化变量的值。
      7. 没lock的变量不能被unlock，也不能unlock被其他线程lock的变量。
      8. 对一个变量执行unlock之前须先执行store、write。  
      
   这些规则有些繁琐，不过可以在描述上简化为四种：read、write、lock、unlock。
3. **volatile**：JVM提供的最轻量级的同步机制，使变量具备可见性，且禁止指令重排序。
4. Java内存模型围绕的问题是，在并发过程中如何处理原子性、可见性、有序性。
   1. 原子性：基本数据类型的读写都是具备原子性的，lock和unlock操作可以满足更大范围的原子性，反映到  
   Java代码中就是代码块同步用到的synchronized关键字。
   2. 可见性：除了volatile，还有final、synchronized能实现可见性。final修饰的字段的不可修改，天然可见。
   3. 有序性：volatile和synchronized会禁止指令重排序，所以保证有序。
5. **线程**的实现有三种：内核线程（1:1）、用户线程（1:N）、混合实现（M:N）。Java在JDK 1.2用过用户线程  
  实现（绿色线程），之后就普遍使用内核线程了。内核线程的优点是直接利用操作系统的线程模型进行调度，  
   无须自己实现各种细节。但缺点比较切换和调度的成本高昂。
6. Java线程状态有6种：New、Running、Waiting、Timed Waiting、Blocked、Terminated。
7. 于是，协程再度得到更多关注。既然1:1模型的调度重，需要用户-内核态来回切换，那用户可实现自己的多线  
  程工作模式的模拟过程。最初这些实现都是协同调度的，所以被称为协程。不使用栈的实现称为无栈协程。
8. 纤程（Fiber）：一种有栈协程，代码会被分为执行过程、调度器两个部分。前者负责维护执行现场，保护和  
  恢复上下文状态，后者负责编排所有要执行代码的顺序。


**深入理解Java虚拟机** 完结 Jul 4<br>
*线程安全和锁优化*
1. Java中的线程安全，是指对象操作后的正确性。按照程度由强到弱分为5类：
   1. 不可变：final修饰的变量一旦被正确构建（没发生this逃逸），那其外部可见的状态永远不会改变。
   2. 绝对线程安全：不管运行时环境如何，调用者都不需要任何额外同步措施。一般实现代价很高，我们知道  
   Vector是线程安全的，但也不属于该类别，因为下面vector操作就无法保证安全：
      ```
      // 下面循环在线程A中，可能报错访问越界
       for(int i=0; i<vector.size(); i++)
           vector.get(i);
      // 下面循环在线程B中
       for(int i=0; i<vector.size(); i++)
           vector.remove(i);
      ```
   3. 相对线程安全：单次操作都是安全的，Vector中方法，属于该类。
   4. 线程兼容：对象本身不安全，但是可以通过在调用段正确地同步来保证并发环境中安全使用。例如上例：
      ```
      // 上面例子中的循环，可以放入synchronized代码块，实现安全操作
      synchronized(vector) {
           for(int i=0; i<vector.size(); i++)
           vector.get(i);
      }
      ...
      synchronized(vector) {
           for(int i=0; i<vector.size(); i++)
           vector.get(i);
      }
      ```
   5. 线程对立：无论是否采用同步措施，都无法在多线程环境中并发使用。如Thread的suspend()和resume()  
   方法，它们现已被声明Deprecated。另外System的setIn()、setOut()和runFinalizersOnExit()也是对立的。
2. 线程安全的实现方法：
   1. 互斥同步：让共享数据同时只被一个（或一些）线程访问，比如临界区、信号量、互斥量。Java中主要用  
     synchronized完成互斥，也用ReentrantLock，前者更简单，但后者支持更多使用需求：等待时可中断、  
     公平锁、一个锁绑定多个条件。不过synchronized在JVM中的实现一直在优化，优先使用synchronized。
   2. 非阻塞同步：相较于互斥同步的性能开销——阻塞、唤醒需要用户态和内核态切换，非阻塞同步采用冲突  
     检测的乐观并发策略，在竞争不激烈时比较有优势。Java中用CAS实现非阻塞同步。
   3. 无同步：a、可重入代码本来就不涉及外部状态，更不存在不一致问题。b、线程本地存储——一段代码中  
   所需数据须与其他代码共享而能保证在同一个线程中执行，那可以用ThreadLocal实现线程本地存储，其  
   底层是用ThreadLocalMap（线程ID为key）实现不同线程所用数据的隔离。
3. 锁优化：JDK 6做了大量改进以支持高并发，包括各种锁优化技术：
   1. 自旋锁与自适应自旋：在多核处理器存在时，请求锁而被阻塞的线程可以不放弃处理器时间稍等一会儿，  
   循环（自旋）等待锁被释放。自适应锁则是根据上次自旋情况，判断这次自旋能否抢到锁。如果是，那就  
   可以多等几次自旋，否则直接省略掉自旋过程，避免处理器资源的浪费。
   2. 锁消除：消除没有必要加的锁，这个锁可能是javac编译时自己加上的。
   3. 锁粗化：若一些列连续操作都对同一个对象反复加锁和解锁，甚至在循环体中，那么就扩大锁的范围到  
    整个操作序列的外部，减少不必要的性能消耗。
   4. 轻量级锁：竞争少的情况下，同步对象没有被锁定的话，虚拟机会在当前线程的栈帧中建立一个Lock   
   Record空间，存储锁对象Mark Word的拷贝，Mark Word以CAS的方式更新为指向Lock Record的指针。  
   若更新失败，那说明有竞争，JVM会检查对象的Mark Word是否指向自己，是的话就直接进入同步块继续  
   执行，否则说明锁对象被其他线程抢占。若2以上的线程争用一个锁，那就膨胀为重量级锁。
   5. 偏向锁：没竞争的情况下干脆连CAS都不用了，直接执行。背后是线程在第一次访问时将偏向模式置位，  
   并且用CAS将Mark Word更新为自己的线程ID。如果有其他线程访问，则撤销偏向锁，变为未锁定或轻量  
   级锁定状态。偏向锁也不适合竞争大的场景。

