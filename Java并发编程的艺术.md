《Java并发编程的艺术》June 11 
1. Java SE1.6对**synchronized**关键字做了优化，使它不再是简单的重量级锁，而有了锁升级的概念。  
  它对应的锁的状态存放在对象头MarkWord中，分别有无锁、偏向锁、轻量级锁、重量级锁四种状态。  
  Markword中存放的部分数值：  
    
    |锁状态|是否偏向| 锁标志位 |其他位|
    |---|---|---|---|
    |无锁|0|01||
    |偏向锁|1|01|有若干位存放线程ID|
    |轻量级锁| |00|指向栈帧中锁记录的指针|
    |重量级锁| |10|指向重量级锁的指针|
   当对象被创建时无锁，一个进程访问同步块时，变**偏向锁**（CAS设置标志位和线程ID），可重入。  
   若关闭偏向锁，有线程访问同步块时，会在栈上分配空间存放MarkWord，然后用CAS操作将MarkWord  
   中指针指向它，即膨胀为**轻量级锁**。当存在竞争失败时，锁会升级成**重量级**锁，失败的线程变阻塞状态。

2. 在Java语言层面可用CAS实现原子操作，它利用的是CPU的CMPXCHG这一原子指令。
3. AbstractQueuedSynchronizer（简称AQS）是Java提供的各种锁的核心，本质上是一个状态和队列，用于  
  线程间的同步，线程通过CAS改变状态值和入队，以获得执行的机会，或去排队等待执行的机会。

子类只需要实现自己的获取锁逻辑和释放锁逻辑即可，至于排队阻塞等待、唤醒机制均由AQS来完成。

《Java并发编程的艺术》June 18  
1. **ReentrantLock**：实现了Lock接口，可重入，构造器支持指定设置锁的公平性，默认是非公平锁。
   1. 公平锁：调用lock方法时，不管是否有线程排队，直接用CAS抢锁，失败才排队。
   2. 非公平锁：调用lock方法时，先确认是否需要排队，不需要才用CAS抢锁。
   3. 两种锁都继承Sync，Sync继承AQS，用它的state记录重入次数。
   4. 公平锁效率较低，因为线程需等待前驱线程获取并释放锁后才能继续获取，可能导致线程切换增加。
2. **ReentrantReadWriteLock**：
   1. 仍用state表示读写锁状态，高16位对应写，低16位对应读。被读、写锁共用，好处：方便原子操作。
   2. 由于读间不互斥，写之间互斥，故读多写少的情况下，读容易导致写线程的饥饿。为了避免这个问题，  
     公平锁的实现跟重入锁的类似，读线程先排队；非公平，让读线程在队列头是写线程的情况下去排队。
   3. 写锁的公平/非公平锁的获取跟重入锁没区别。


《Java并发编程的艺术》June 22
1. Java内存模型（JMM）之所以存在，是因为并发编程要解决两个关键问题：
   1. 线程间通信：线程间交换信息的机制。有两种，消息传递和共享内存，Java用的是后者。
   2. 线程间同步：程序中用于控制不同线程间操作发生相对顺序的机制，它是显式进行的，由程序员控制。
2. JMM通过控制主内存与每个线程本地内存（抽象概念，包括CPU缓存、写缓冲区、寄存器等）。
3. 指令重排序问题：源代码->编译器优化重排序->指令级并行重排序->内存系统重排序->最终执行序列。  
  重排序会导致多线程问题，例子：

   | |处理器A|处理器B|
   |----|---|----|
   |代码|a = 1; // A1<br/>x = b; // A2| b = 2; // B1<br/>y = a; // B2
   |允许的运行结果|x = 0| y = 0

   因为经过重排序，指令可能的顺序是A2，B2，A1，B1，这个结果是从线程的视角看内存操作，关键问题：  
   写缓冲的存在使指令的执行顺序跟内存的操作顺序出现不一致，需要JMM保障正确性。
4. 我们用happens-before概念表示JMM中操作的可见性，它规定了多种编译器和处理器的重排序规则。
5. 再看重排序影响多线程结果的例子：
    ```java
    class ReorderExample {
        int a = 0;
        boolean flag = false;
        public void write() {
            a = 1;       // 1
            flag = true; // 2
        }
        public int read() {
            if (flag) {        // 3
                int b = a * a; // 4
                // omitted ...
            }
        }
    }
    ```
   线程A调用write，线程B调用read，可能出现b=0，因为1和2可能重排序，使得执行顺序为2->3->4->1。
6. 要避免上述问题，可以给flag加volatile，使其写-读建立happens-before关系，保证1->2->3-4>的顺序。  
  JSR-133增强的volatile的内存语义，不允许volatile变量与普通变量重排序，否则还是避免不了上述问题。
7. 除了volatile，JMM对final也有内存屏障，以避免final域的写排到构造器之外。

《Java并发编程的艺术》June 25
1. Java线程的interrupt方法用于打断一个线程，将中断标志位置位，isInterrupted方法则可以判断中断标志，  
  interrupted方法则清除标志位。很多抛出中断异常的方法如sleep都是先清除标志位再抛出异常的。
2. suspend、stop和resume方法之所以被deprecated，是因为suspend不释放资源进入睡眠状态，这样容易  
 引发死锁；而stop方法终结一个线程时不会保证线程的资源正常释放，使程序工作在不确定状态下。
3. 通过interrupt和isInterrupted方法或中断标志位是推荐的中断线程的方式。有中断异常的方法能及时响应  
  interrupt，方便不用标志位就中断执行过程。
4. wait(long)方法的参数表示超时时间，一旦到达，无需别的线程调用notify或notifyAll方法也会醒来再度抢锁，  
  继续进行执行后续的代码。

《Java并发编程的艺术》July 4
1. **AQS**作为JUL包中个钟锁和并发工具类的核心，维护了一个状态和一个双向队列，提供了使线程等待和  
  唤醒线程的功能。这使得Java并发编程有了更多手段，也更加灵活。
2. AQS作为一个抽象类并没有抽象方法，而是有5个抛出异常的protected方法，它们分别是：
   1. `boolean tryAquire(int)`尝试获取锁，返回true表示获取到锁。
   2. `boolean tryRelease(int)`尝试释放锁，返回true表示释放了锁。
   3. `int tryAcquireShared(int）`尝试获取共享锁，返回正数表示获取到锁。
   4. `boolean tryReleaseShared(int)`尝试释放共享锁，返回true表示释放锁成功。
   5. `boolean isHeldExclusively()`返回当前线程是否持有锁。  
    state具体什么含义、上述方法如何操作state都是是实现者定义的。前4个方法一般都会尝试修改state，  
   为保证原子性，需要用CAS的方式进行。AQS以它们作为钩子，根据其结果来调用真正的获取、释放锁  
   操作。1和2由互斥锁实现，3和4由共享锁实现。
3. 比如ReentrantLock，获取锁时，try失败则进入等待状态。被唤醒后会再次try，成功则将自己设置为队列的  
  头结点。锁的释放也是先try修改state，成功则唤醒后继结点的线程。
4. 再如Semaphore类，获取锁失败的线程从等待状态被唤醒时，会再次try并将自己设置为头，适时唤醒后一个  
   排队的线程。锁的释放也会唤醒等待排在后面的线程。
